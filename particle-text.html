<!doctype html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Particle Text Canvas</title>
<style>
  html,body{
    height:100%;
    margin:0;
    background: radial-gradient(circle at 20% 20%, #111022 0%, #0d0b1a 35%, #07050a 100%);
    overflow:hidden;
    font-family: "Segoe UI", Roboto, Arial, sans-serif;
    color:#fff;
  }
  #canvas{
    display:block;
    width:100%;
    height:100%;
  }
  .overlay {
    position: absolute;
    left: 20px;
    top: 20px;
    z-index: 10;
    font-weight:600;
    letter-spacing:0.04em;
    color: rgba(255,255,255,0.85);
    text-shadow: 0 6px 18px rgba(0,0,0,0.6);
    user-select:none;
  }
  .small {
    font-size:14px;
    opacity:0.85;
  }
  .hint {
    position: absolute;
    left: 20px;
    bottom: 20px;
    z-index:10;
    color: rgba(255,255,255,0.65);
    font-size:13px;
  }
  button {
    background: linear-gradient(90deg, #ff9a9e, #fad0c4);
    border: none;
    padding: 8px 12px;
    border-radius: 8px;
    cursor:pointer;
    box-shadow: 0 6px 18px rgba(0,0,0,0.35);
    font-weight:700;
  }
</style>
</head>
<body>
<div class="overlay">
  <div style="font-size:20px">DLUONGTA PARTICLE TEXT</div>
  <div class="small">Particles forming text: 3 → 2 → 1 → CHUC MUNG SINH NHAT → 09/01/2003 → DINH LUONG TA → DLUONGTA</div>
  <div style="margin-top:8px">
    <button id="restart">Chạy lại</button>
    <button id="toggleAccent">Chữ có dấu: TẮT</button>
  </div>
</div>
<canvas id="canvas"></canvas>
<div class="hint">Đây là website được tạo ra bởi DINH LUONG TA. Trang web sử dụng hiệu ứng PARTICLE TEXT CANVAS.</div>

<script>
(() => {
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d', { alpha: true });
  let DPR = window.devicePixelRatio || 1;

  function resize(){
    DPR = window.devicePixelRatio || 1;
    canvas.width = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(window.innerHeight * DPR);
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Offscreen canvas used to render text to pixel map
  const off = document.createElement('canvas');
  const offCtx = off.getContext('2d');

  // Configuration
  const particleSize = 2.2; // visual size
  const sampleGap = 6; // sample every N pixels when scanning text
  const formDuration = 900; // ms to tween to target positions
  const holdDuration = 700; // ms hold before explode
  const explodeDuration = 800; // ms for disperse
  const betweenDuration = 200; // pause between phases
  const textsUnaccented = ['3','2','1','CHUC', 'MUNG', 'SINH' ,'NHAT','09/01/2003','DINH LUONG TA', 'DLUONGTA'];
  const textsAccented = ['3','2','1','CHÚC', 'MỪNG', 'SINH', 'NHẬT','09/01/2003','ĐÌNH LƯƠNG TẠ', 'DLUONGTA'];
  let useAccent = false;

  let particlePool = []; // pool to re-use particles
  let particles = []; // active particles
  let lastTime = performance.now();

  // Sequence control
  let sequence = [];
  let seqIndex = 0;

  // helper easing
  function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }
  function lerp(a,b,t){ return a + (b - a) * t; }

  class Particle {
    constructor(x=0,y=0, color = 'white') {
      this.x = x;
      this.y = y;
      this.vx = 0;
      this.vy = 0;
      this.tx = x;
      this.ty = y;
      this.color = color;
      this.life = 1;
      this.size = particleSize;
      this.phase = 0; // 0: moving to target, 1: exploded, 2: idle
      this.startTime = 0;
      this.startX = x;
      this.startY = y;
      this.duration = formDuration;
      this.alpha = 1;
    }
    to(targetX, targetY, now, dur=formDuration){
      this.phase = 0;
      this.startX = this.x;
      this.startY = this.y;
      this.tx = targetX;
      this.ty = targetY;
      this.startTime = now;
      this.duration = dur;
      // subtle color variation
      const hue = 200 + Math.random() * 140;
      this.color = `hsla(${hue}, 85%, ${45 + Math.random()*10}%, 1)`;
    }
    explode(now){
      this.phase = 1;
      const angle = Math.random() * Math.PI * 2;
      const speed = 2 + Math.random() * 6;
      this.vx = Math.cos(angle) * speed;
      this.vy = Math.sin(angle) * speed - (1 + Math.random() * 1.5);
      this.startTime = now;
      this.duration = explodeDuration;
      this.alpha = 1;
    }
    update(dt, now){
      if (this.phase === 0){
        const t = Math.min(1, (now - this.startTime) / this.duration);
        const e = easeOutCubic(t);
        this.x = lerp(this.startX, this.tx, e);
        this.y = lerp(this.startY, this.ty, e);
        this.alpha = 0.95;
        if (t >= 1) {
          this.phase = 2; // arrived
        }
      } else if (this.phase === 1){
        // ballistic with damping
        this.vy += 0.06 * (1 + Math.random()*0.5); // gravity
        this.x += this.vx;
        this.y += this.vy;
        // fade out slowly
        const t = Math.min(1, (now - this.startTime) / this.duration);
        this.alpha = 1 - t;
        if (t >= 1) this.alpha = 0;
      } else {
        // idle slight float
        this.y += Math.sin(now/800 + this.x*0.001) * 0.02;
      }
    }
    draw(ctx){
      ctx.globalAlpha = Math.max(0, this.alpha);
      // soft glow
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.size, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }

  function createOrReuseParticle(x,y){
    let p;
    if (particlePool.length > 0){
      p = particlePool.pop();
      p.x = x; p.y = y;
      p.startX = x; p.startY = y; p.alpha = 1;
    } else {
      p = new Particle(x,y);
    }
    return p;
  }

  // Build pixel targets from text; returns array of {x,y}
  function buildTargetsForText(text, maxWidth){
    // choose font size based on canvas width
    const w = Math.min(window.innerWidth, 1200);
    let fontSize;
    if (text.length <= 3) {
      fontSize = Math.round(w * 0.45);
    } else {
      fontSize = Math.round(w * 0.12);
    }
    // adjust for very small screens
    fontSize = Math.max(28, Math.min(fontSize, 420));

    off.width = Math.floor(Math.min(maxWidth, canvas.width / DPR));
    off.height = Math.floor(Math.min(400, canvas.height / DPR));
    offCtx.clearRect(0,0,off.width,off.height);

    offCtx.textBaseline = 'middle';
    offCtx.textAlign = 'center';
    offCtx.fillStyle = '#fff';
    offCtx.font = `bold ${fontSize}px "Segoe UI", Roboto, Arial`;
    // center
    const cx = off.width / 2;
    const cy = off.height / 2;
    offCtx.fillText(text, cx, cy);

    // get pixel data
    const img = offCtx.getImageData(0,0, off.width, off.height);
    const data = img.data;
    const targets = [];
    for (let y = 0; y < off.height; y += sampleGap){
      for (let x = 0; x < off.width; x += sampleGap){
        const idx = (y * off.width + x) * 4;
        const alpha = data[idx + 3];
        if (alpha > 120){
          // map to visible canvas coords
          // place the text vertically center in the main canvas
          const scale = 1; // we already sized off canvas
          const tx = (x - off.width/2) + (canvas.width / DPR) / 2;
          const ty = (y - off.height/2) + (canvas.height / DPR) / 2;
          targets.push({x: tx, y: ty});
        }
      }
    }
    return targets;
  }

  // Build sequence (targets arrays) from texts
  function buildSequence(){
    const arr = useAccent ? textsAccented : textsUnaccented;
    sequence = arr.map(t => buildTargetsForText(t, Math.floor(canvas.width / DPR) - 80));
    seqIndex = 0;
  }

  // initialize particles to random positions (off-screen top)
  function initParticles(count){
    particles.length = 0;
    for (let i = 0; i < count; i++){
      const px = Math.random() * (canvas.width / DPR);
      const py = Math.random() * (canvas.height / DPR);
      const p = createOrReuseParticle(px, py);
      p.phase = 2;
      particles.push(p);
    }
  }

  // assign particles to targets (reusing or creating)
  function assignToTargets(targets, now){
    // ensure at least as many particles as targets (we'll create extras if needed)
    if (particles.length < targets.length){
      const need = targets.length - particles.length;
      for (let i = 0; i < need; i++){
        const px = Math.random() * (canvas.width / DPR);
        const py = Math.random() * (canvas.height / DPR);
        particles.push(createOrReuseParticle(px,py));
      }
    }
    // shuffle particles a little for nicer distribution
    // sort by distance to center for more natural effect
    const cx = (canvas.width / DPR)/2, cy = (canvas.height / DPR)/2;
    particles.sort((a,b) => (Math.hypot(a.x-cx,a.y-cy) - Math.hypot(b.x-cx,b.y-cy)));

    // assign first N particles to the targets
    for (let i = 0; i < targets.length; i++){
      const t = targets[i];
      const p = particles[i];
      p.to(t.x + (Math.random()-0.5)*0.6, t.y + (Math.random()-0.5)*0.6, now, formDuration + Math.random()*200);
    }
    // remaining particles: send off-screen or random idle positions
    for (let i = targets.length; i < particles.length; i++){
      const p = particles[i];
      // make them float around edges
      const edgeX = Math.random() < 0.5 ? -30 : (canvas.width / DPR) + 30;
      const py = Math.random() * (canvas.height / DPR);
      p.to(edgeX, py, now, 1000 + Math.random()*800);
    }
  }

  // Explode effect
  function explodeAll(now){
    for (let p of particles){
      // only explode those close to where they were (phase 2)
      p.explode(now);
    }
  }

  // Main timeline controller
  let timelineHandle = null;
  function startSequence(){
    // build sequence for current size and accent setting
    buildSequence();
    // start with initial particles count equal to max targets length
    const maxCount = Math.max(...sequence.map(a=>a.length));
    initParticles(Math.min(1500, maxCount + 200));
    seqIndex = 0;
    runNextStage();
  }

  function runNextStage(){
    if (!sequence.length) return;
    const now = performance.now();
    const targets = sequence[seqIndex];
    assignToTargets(targets, now);
    // schedule hold -> explode -> next
    clearTimeout(timelineHandle);
    // hold after forming
    timelineHandle = setTimeout(() => {
      // explode
      explodeAll(performance.now());
      // after explodeDuration + a bit, move to next text
      timelineHandle = setTimeout(() => {
        seqIndex++;
        if (seqIndex >= sequence.length){
          // final hold and then stop or loop
          timelineHandle = setTimeout(() => {
            // after a short pause, re-run sequence once or loop
            // let's loop
            seqIndex = 0;
            runNextStage();
          }, 1200);
        } else {
          runNextStage();
        }
      }, explodeDuration + betweenDuration);
    }, formDuration + holdDuration);
  }

  // render loop
  function render(now){
    const dt = now - lastTime;
    lastTime = now;
    // clear with slight fade for trails
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // background subtle stars
    drawBackground(ctx, now);

    // update and draw particles
    for (let i = 0; i < particles.length; i++){
      const p = particles[i];
      p.update(dt, now);
    }

    // draw glow by drawing bigger circles behind
    ctx.save();
    ctx.globalCompositeOperation = 'lighter';
    for (let i = 0; i < particles.length; i++){
      const p = particles[i];
      ctx.globalAlpha = Math.min(0.9, p.alpha * 0.9);
      ctx.beginPath();
      ctx.fillStyle = p.color;
      // glow
      ctx.arc(p.x, p.y, p.size * 2.8, 0, Math.PI*2);
      ctx.fill();
    }
    // main dots
    for (let i = 0; i < particles.length; i++){
      const p = particles[i];
      ctx.globalAlpha = Math.min(1, p.alpha);
      ctx.beginPath();
      ctx.fillStyle = '#fff';
      // tiny inner highlight
      ctx.arc(p.x, p.y, Math.max(0.9, p.size * 0.9), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();

    requestAnimationFrame(render);
  }

  // Simple starfield background
  // let stars = [];
  // function buildStars(){
  //   stars = [];
  //   const n = Math.floor((canvas.width / DPR) * (canvas.height / DPR) / 12000);
  //   for (let i = 0; i < n; i++){
  //     stars.push({
  //       x: Math.random() * (canvas.width / DPR),
  //       y: Math.random() * (canvas.height / DPR),
  //       r: Math.random() * 1.6 + 0.2,
  //       a: 0.2 + Math.random() * 0.6,
  //       tw: Math.random() * Math.PI * 2
  //     });
  //   }
  // }
  function drawBackground(ctx, now){
    // gradient vignette
    const w = canvas.width / DPR, h = canvas.height / DPR;
    const g = ctx.createRadialGradient(w*0.5, h*0.4, Math.min(w,h)*0.1, w*0.5, h*0.4, Math.max(w,h)*0.9);
    g.addColorStop(0, 'rgba(20,12,40,0.85)');
    g.addColorStop(0.5, 'rgba(10,6,20,0.7)');
    g.addColorStop(1, 'rgba(2,2,6,0.9)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // stars
    // if (stars.length === 0) buildStars();
    // ctx.save();
    // ctx.globalCompositeOperation = 'lighter';
    // for (let s of stars){
    //   const tw = Math.sin(now/1000 + s.tw) * 0.5 + 0.5;
    //   ctx.globalAlpha = s.a * tw * 0.9;
    //   ctx.beginPath();
    //   ctx.fillStyle = 'rgba(255,255,255,1)';
    //   ctx.arc(s.x, s.y, s.r * (0.6 + tw*0.8), 0, Math.PI*2);
    //   ctx.fill();
    // }
    // ctx.restore();
  }

  // UI handlers
  document.getElementById('restart').addEventListener('click', () => {
    clearTimeout(timelineHandle);
    particlePool.push(...particles);
    particles = [];
    startSequence();
  });

  const taBtn = document.getElementById('toggleAccent');
  taBtn.addEventListener('click', () => {
    useAccent = !useAccent;
    taBtn.textContent = 'Chữ có dấu: ' + (useAccent ? 'BẬT' : 'TẮT');
    // restart with new text set
    clearTimeout(timelineHandle);
    particlePool.push(...particles);
    particles = [];
    startSequence();
  });

  // initial run
  startSequence();
  requestAnimationFrame(render);

  // on resize, rebuild everything
  window.addEventListener('resize', () => {
    // small debounce
    clearTimeout(resize._t);
    resize._t = setTimeout(() => {
      buildSequence();
      // buildStars();
      // reassign current stage targets to fit new layout
      const now = performance.now();
      const targets = sequence[seqIndex] || sequence[0];
      if (targets) assignToTargets(targets, now);
    }, 120);
  });

})();
</script>
</body>
</html>
